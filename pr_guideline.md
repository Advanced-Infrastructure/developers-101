# Pull requests

- [Ensure you can be identified from your Github account](#ensure-you-can-be-identified)
- [Leave pull requests in draft until they are potentially ready to merge](#leave-in-draft)
- [Don't request a review until tests have passed](#dont-request-review-until-tests-passed)
- [Keep pull requests small](#keep-prs-small)
- [Write commit subjects in the imperative mood](#imperative-commit-subjects)
- [Do only one thing with each commit](#do-only-one-thing-with-each-commit)
- [Don't mix refactoring with functional changes in the same commit](#dont-mix-refactoring-with-functional-changes)
- [Make each commit atomic](#atomic-commits)
- [Try not to surprise reviewers with urgent, complex pull requests](#dont-surprise-with-urgent-prs)
- [Acknowledge every review comment](#acknowledge-comments)
- [When re-requesting reviews, make it clear what has changed](#make-clear-what-has-changed-since-last-review)


## <a name="ensure-you-can-be-identified">Ensure you can be identified from your Github account</a>

Make sure that your full name is displayed on the GitHub account you use for developing. Without it, it
can be difficult to map authors back to real people.

If you're not comfortable having your full name on your personal GitHub profile, please create a separate GitHub profile
to use for work and add your name to that.


## <a name="leave-in-draft">Leave pull requests in draft until they are potentially ready to merge</a>

When first opening a pull request, use [GitHub‚Äôs ‚Äòdraft‚Äô feature] to create it as a draft. This will prevent code owners
from being tagged prematurely.

Only once you feel it is potentially production-ready, mark it as 'ready for review'. This will then automatically tag
the code owners.

If you want to get an early review while a pull request is still in draft, that's fine.

[github‚Äôs ‚Äòdraft‚Äô feature]: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests#draft-pull-requests


## <a name="dont-request-review-until-tests-passed">Don't request a review until tests have passed</a>

By default, wait for the test suite to pass before asking for a review. One of main purposes of the tests (in particular, the
linting) is to save a reviewer's time by picking up on issues that would otherwise be flagged by a human.

Sometimes unrelated tests '[flake]'. Run the Ruff workflow before requesting a review.

Install and configure:
1. Configure and set up ruff locally with toml file (standard plus additional rule if needed).
2. Configure and install pre-commit hook on local (steps to be shared by yogesh).
3. Ensure ruff check and Precommit checks are passed before raising a PR.

The only exceptions to requesting a review with failing tests should be when:

- There are failing tests on the master/main branch that are unrelated to your changes. Try to rebase your branch as soon these
  are fixed, but it doesn't need to block a review.
- You need the reviewer's help to fix the tests or provide early feedback that you're going in the right direction. In this case, make sure the pull request is still in draft, as it isn't
  production ready.

In either case, mention in your pull request description why there are failing tests.



[flake]: https://tech.octopus.energy/news/2022/05/23/flakey-python-tests.html
[rerun the circleci workflow from failed]: https://support.circleci.com/hc/en-us/articles/360050303671-How-To-Rerun-a-Workflow

## <a name="keep-prs-small">Keep pull requests small</a>

Avoid big pull requests. They are:

- hard to review;
- can get bogged down with too many comments;
- more likely to incur git conflicts;
- riskier to deploy.

There's no hard-and-fast rule as to what constitutes too big a pull request, but if it's running to more than a few
hundred lines of code then it's probably worth breaking up. If there are dependencies from one
PR to another, [chain them](#chain-prs). (If you've [made each commit atomic](#atomic-commits), this should
be easy: you can just move later commits to another PR.)

Don't apologise about a pull request being too big; break it up before seeking review. It is time well spent.

It's never too late to break up a PR. If one becomes unexpectedly big or difficult during the review process, don't soldier on: it quickly becomes demoralizing for everyone. Instead, identify smaller parts, break them out into separate pull requests, and focus on getting them merged incrementally.

## <a name="imperative-commit-subjects">Write commit subjects in the imperative mood</a>

Write imperative commit subjects, e.g. "Fix bug" rather than "Fixed bug" or
"Fixes bug." This convention matches up with commit messages generated by
commands like `git merge` and `git revert`.

Tip: if you've done it correctly, the commit subject will complete the sentence, "If merged, this commit will..."

## <a name="do-only-one-thing-with-each-commit">Do only one thing with each commit</a>

Express a single thought with each commit. This can result in very small commits
(e.g. fixing a typo) or quite large ones (e.g. moving many modules to
different package). The point is that a reviewer should be able to hold the commit
in their head without too much trouble.

What constitutes 'a single thought' is a judgement call. You may choose to add
several interdependent Django models in a single commit, as it makes sense to be
reviewed as a single thing: in this case, the data model. You may choose to
use one commit to add type annotations for an entire module, because it is
ultimately driven by one thought. The golden rule is that it should make the life
of the reviewer easier.

If you're writing 'change this and that' in a commit message, it's a strong indication that you should break up the commit.

## <a name="dont-mix-refactoring-with-functional-changes">Don't mix refactoring with functional changes in the same commit</a>

It's hard to review commits that contain both refactoring (changes to the way code is expressed) and functional changes. Split them up so refactoring stands on its own.

## <a name="atomic-commits">Make each commit atomic</a>

Before a pull request merges, its commits should be self-contained (a.k.a. "atomic").

This means that after each commit:

- The test suite should pass;
- The codebase could be safely deployed to production.

So don't half-implement a feature in one commit then fix it in a later commit. Structure your pull requests so that each change keeps the codebase in a deployable state.

Tip: if you want to write a failing test and then fix it in a later commit, you can keep the test suite passing by
decorating the test with `pytest.mark.xfail`.

## <a name="dont-surprise-with-urgent-prs">Try not to surprise reviewers with urgent, complex pull requests</a>

If you have a time-sensitive pull request that you are preparing, engage with your intended reviewers ahead of time to
let them know it's coming.

Complex PRs can take a lot of time to review: if you need a fast turnaround, the more notice the better.

## <a name="acknowledge-comments">Acknowledge every review comment</a>

Always respond to every comment to indicate to the reviewer that you‚Äôve seen and thought about what they said. This
doesn't have to be onerous: often a üëç reaction is sufficient.

## <a name="acknowledge-comments">Acknowledge every review comment</a>

Always respond to every comment to indicate to the reviewer that you‚Äôve seen and thought about what they said. This
doesn't have to be onerous: often a üëç reaction is sufficient.

## <a name="make-clear-what-has-changed-since-last-review">When re-requesting reviews, make it clear what has changed</a>

When re-requesting a review after some requested changes, make it clear to the reviewer what has changed since their
last review. This helps them save time as they may not remember where they reviewed up to last time.

There are a few approaches for doing this:

### <a name="comment-and-rewrite-history">Approach A: comment and then rewrite history</a>

One way to address changes is to amend previous commits.

If you're doing this it can force the reviewer to look back and reread lots of code they have already reviewed, so help
them out by communicating each change with a PR comment.

### <a name="show-changes-using-additional-commits">Approach B: show changes using additional commits</a>

Alternatively, you can make changes by adding commits on top of what you have already done, leaving the original commits
in place. You can, if you like, use [fixup commits] to do this. If you do this, it's helpful also to let the reviewer know which commit to review from.

Additional commits make changes clearer to the reviewer, but it has the downside of a messier commit history which will need to
be tidied up before merge.

Don't forget to squash the corrections together before merging, as per
[Clean up mistakes by rewriting history](#clean-up-mistakes). You can add the _Fixup before merging_ label to your PR to
remind yourself.